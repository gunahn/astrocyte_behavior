import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from statistics import mean
import os
import glob

def plot_svg_and_take_peaks(variable_name, animal_number, path, day, today):
    df = pd.read_csv(path)
    df = df.drop(columns=['Unnamed: 0'])
    signal = df[1000:]
    signal = signal.reset_index(drop=True)
    # get the last index of initiation == 0
    last_initiation = signal[signal['TTL_initiation'].diff() == -1]['relative_time'].index[-1]
    # exclude data after the last initiation
    signal = signal[:last_initiation+300]
    #reset the index
    signal = signal.reset_index(drop=True)

    change_signal_init = signal[signal.TTL_initiation.diff() == -1]
    df_diff = pd.DataFrame(change_signal_init['relative_time'].diff())
    b_plot = df_diff.boxplot()
    outliers = b_plot.get_lines()[-1].get_ydata()
    q1 = b_plot.get_lines()[2].get_ydata()[0]
    q3 = b_plot.get_lines()[3].get_ydata()[0]
    max_except_outliers = b_plot.get_lines()[2].get_ydata()[1]
    hist, bin_edges = np.histogram(change_signal_init['relative_time'].diff()[1:])
    print(hist)
    print(bin_edges)
    criteria = q1
    criteria_name = 'q1'
    # find the times that change_signal_init['relative_time'].diff() is greater than max_except_outliers
    habitual_time = change_signal_init['relative_time'][change_signal_init['relative_time'].diff() < criteria]
    # find the times that change_signal_init['relative_time'].diff() is less than max_except_outliers
    non_habitual_time_start = change_signal_init['relative_time'][change_signal_init['relative_time'].diff() > criteria]
    # calculate the non_habitual_time_period in index format
    periods = []
    periods_in_time = []

    for end_point in non_habitual_time_start.index:
        index_of_start = list(change_signal_init['relative_time'].diff().index).index(end_point) - 1
        starting_point = change_signal_init['relative_time'].diff().index[index_of_start]
        periods.append((starting_point, end_point))
        periods_in_time.append(
            (change_signal_init['relative_time'][starting_point], change_signal_init['relative_time'][end_point]))

    # show the periods with the graph of signal
    signal['Hapitual_phase'] = True

    for period in periods:
        signal.loc[period[0]:period[1], 'Hapitual_phase'] = False
    # calculate the number of peaks in each period
    number_of_peaks_habitual = []
    number_of_peaks_non_habitual = []
    # calculate the number of peaks in each period
    peaks, peak_heights = find_peaks(signal[variable_name], distance=300,
                                     height=np.quantile(signal[variable_name], 0.99))
    for peak in peaks:
        if peak in signal[signal['Hapitual_phase'] == True].index:
            number_of_peaks_habitual.append(peak)
        else:
            number_of_peaks_non_habitual.append(peak)
    sum_total = len(number_of_peaks_habitual[1:]) + len(number_of_peaks_non_habitual)
    probablity_habit = len(number_of_peaks_habitual[1:]) / sum_total
    probablity_non_habit = len(number_of_peaks_non_habitual) / sum_total
    plt.clf()
    # plt.scatter(signal[signal['TTL_correct_choice'].diff()==-1]['relative_time'], signal[signal['TTL_correct_choice'].diff()==-1]['TTL_correct_choice']-5, label = 'correct choice',s =0.1)
    # plt.scatter(signal[signal['TTL_turn'].diff()==-1]['relative_time'], signal[signal['TTL_turn'].diff()==-1]['TTL_turn']-4.5, label = 'turn', s =0.1)
    # plot non-hapitual phase
    peak_heights['peak_heights'].sort()

    second_height = peak_heights['peak_heights'][-1]
    plt.scatter(signal[signal['TTL_initiation'].diff() == -1]['relative_time'],
                signal[signal['TTL_initiation'].diff() == -1]['TTL_initiation'] + second_height + 0.2,
                label='initiation', s=1)

    for period in periods_in_time[:-1]:
        plt.plot(period, np.zeros(len(period)) + second_height + 0.5, color='red')

    plt.plot(periods_in_time[-1], np.zeros(len(periods_in_time[-1])) + second_height + 0.5, color='red',
             label='Exploitation')
    plt.plot(signal['relative_time'][number_of_peaks_habitual], signal[variable_name][number_of_peaks_habitual], "x",
             label='Peaks in exploitation')
    plt.plot(signal['relative_time'][number_of_peaks_non_habitual],
             signal[variable_name][number_of_peaks_non_habitual], "x", color='red', label='Peaks in exploration')

    # plt.plot(signal['relative_time'], (signal['Red-L-z(DA)']), 'r--', label = 'Dopamine L')
    plt.plot(signal['relative_time'], (signal[variable_name]), 'g-', label=variable_name)
    # plt.plot(signal['relative_time'], (signal['Green-L-z(Ast)']), 'g--', label = 'GCaMP L')

    plt.rcParams['pdf.use14corefonts'] = True
    plt.xlabel("Time sec")
    plt.ylabel("Z-score")
    plt.legend(loc='lower right', borderaxespad=0.)
    plt.title('{} signal and peak with behavioral events_animal{}_day{}'.format(variable_name, animal_number, day))
    # put the title of the plot
    # save plot in svg file format
    plt.savefig('/Users/gunahn/Desktop/MIT/Habit_Breaking_Da_Ast/result/{}/{}/GCaMP(R) signal and peak with behavioral events_with_{}_animal{}_day_{}_{}.svg'.format(variable_name, animal_number,criteria_name, animal_number,day,today), format='svg', dpi=1200)

    plt.show()

    return probablity_habit, probablity_non_habit